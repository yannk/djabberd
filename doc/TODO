-- before authenticated (and ever after authenticated) only capture data when people XML nodes
   for a fixed amount of bytes/time before disconnecting client as possibly malicious

-- (10:51:43) matt@sergeant.org: I noticed a problem with DJabberd::DNS
   (10:51:49) matt@sergeant.org: you're using a socket per DNS query
   (10:55:08) matt@sergeant.org: it means your responses end up overlapping if you do more than 65k concurrent queries, and sometimes before then.
   (10:55:48) matt@sergeant.org: there's a long protracted discussion of this in the SpamAssassin archives.
   (10:55:58) matt@sergeant.org: no it often happens way before that many queries
   (10:58:12) matt@sergeant.org: anyhow, feel free to steal qpsmtpd's Danga::DNS

-- SIG USR1 to do graceful shutdown, sending </stream:stream> to all clients.

-- TODO: resource binding?

-- TODO: IQ commands to server to get server load info:
    o #/which connected users
    o #/which connected s2s
    o RAM
    o uptime
    o CPU user/system time

-- shouldn't allow auth with no resource

-- should send a 503 error here on bogus/unsupported IQ:

       4 < <iq id='SgSeu-6' type='get'><query xmlns='jabber:iq:anything'/></iq> INFO  DJabberd.Connection.XML.ClientIn         <iq  to='user0@jabber.bradfitz.com/Smack' type='error' id='SgSeu-6'></iq> WARN  DJabberd.IQ                              Unknown IQ packet: get-{jabber:iq:anything}query


-- presence priority

-- allow a fast path when bulk sending tons of messages (like hundreds of unavailable stanzas
   on disconnect):  allow a means to, given a set of full/bare (at least bare) JIDs, filter out
   the ones to be known not available.  (for instance, local/cluster
   ones, where we're the authority on their presence).

-- optimization:  when sending out presence to ourselves, we double-check the rosteritem
   status for filtering reasons on its way back "in", when it loops back to ourselves in
   procdeliver.  we should set an "its_us_so_trust_us" flag and then
   we fast-path that, avoiding the lookup.

-- can we reuse s2s connections in both directions?  Our code doesn't, but worse,
   I don't think it'd even allow other people to try and do it to us.  What does spec say?

-- s2s and client timeouts

-- cleanup/unifiy callbacks.... error vs. fail, on_data vs set vs loaded, etc...
  give them types?

-- debian install guide.

-- debian packaging

-- make SSL configuration easier:  configurable locations of keys,
   and bitch if configured and not configured

-- $stanza->process and $stanza->deliver take a $conn, but
   now that stanzas always know their connection, that
   parameter is kinda useless.  remove them all?
     -- actually, we should also store a non-weak vhost ref
        in stanzas, then use that for delivery/etc, since
        conn as a weakref can go away if client disconnects
        and we may still want to process/deliver.

-- Jingle/Asterisk stuff:

   This Jabber client supports Jingle:
     http://www.kismith.co.uk/wordpress/index.php/2005/12/16/i-say-i-say-i-say-did-you-hear-the-one-about/
     http://psi-im.org/wiki/Jingle_branch
   So think we could do the Jingle stuff Jabber-server-side and get the Psi
   client connecting to Asterisk over SIP or something?

-- speed up XMLElement as_xml ... try to reuse the original scalarref read from the network, if
   we can align the boundaries of XML stanzas to network reads.  XML::Parser::Expat can help
   us:  (where $self->{parser} is our incremental parser), but we're using LibXML now.

    print Dumper("eobj = " . eval { $self->{parser}->_expat_obj->current_byte });
    $VAR1 = 'eobj = 22';

-- <not-authorized/> -- the sender must provide proper credentials
      before being allowed to perform the action, or has provided
      improper credentials; the associated error type SHOULD be "auth".   no error currently gets sent on non AUTH
