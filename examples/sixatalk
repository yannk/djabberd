#!/usr/bin/perl

use strict;
use lib 'lib';
use DJabberd;

use DJabberd::Delivery::Local;
use DJabberd::Delivery::S2S;

use DJabberd::PresenceChecker::Local;

use DJabberd::RosterStorage::SQLite;
use DJabberd::RosterStorage::Dummy;
use DJabberd::RosterStorage::LiveJournal;


use Getopt::Long;

use vars qw($DEBUG);
$DEBUG = 0;

my ($daemonize);

Getopt::Long::GetOptions(
    'd|daemon'       => \$daemonize,
    'debug=i'        => \$DEBUG,
   );

use FindBin qw($Bin);

my $server = DJabberd->new(
                           server_name => 'sixapart.com',
                           daemonize => $daemonize,
                           s2s       => 0,
                           old_ssl   => 1,
                           plugins   => [
                                         DJabberd::Authen::SixApart->new,
                                         DJabberd::PresenceChecker::Local->new,
                                         DJabberd::Delivery::Local->new,
                                         #DJabberd::Delivery::S2S->new,
                                         DJabberd::RosterStorage::SixApart->new("$Bin/roster.sqlite"),
                                         ],
                           );
$server->run;


package DJabberd::Authen::SixApart;
use strict;
use base 'DJabberd::Authen';
use Net::LDAP;

sub can_retrieve_cleartext { 0 }

sub check_cleartext {
    my ($self, $cb, %args) = @_;
    my $user = $args{username};
    my $pass = $args{password};
    my $conn = $args{conn};

    unless ($user =~ /^\w+$/) {
        $cb->reject;
        return;
    }

    my $ldap = Net::LDAP->new( 'ldap.sixapart.com' ) or die "$@";
    my $dn   = "uid=$user,ou=People,dc=sixapart,dc=com";
    my $msg  = $ldap->bind($dn, password => $pass, version => 3);
    if ($msg && !$msg->is_error) {
        $cb->accept;
    } else {
        $cb->reject;
    }
}


package DJabberd::RosterStorage::SixApart;
use strict;
use base 'DJabberd::RosterStorage::SQLite';

sub get_roster {
    my ($self, $cb, $jid) = @_;
    # cb can '->set_roster(Roster)' or decline

    my $myself = lc $jid->node;
    warn "SixApart loading roster for $myself ...\n";

    my $on_load_roster = sub {
        my (undef, $roster) = @_;

        my $pre_ct = $roster->items;
        warn "  $pre_ct roster items prior to population...\n";

        # see which employees already in roster
        my %has;
        foreach my $it ($roster->items) {
            my $jid = $it->jid;
            next unless $jid->as_bare_string =~ /^(\w+)\@sixapart\.com$/;
            $has{lc $1} = $it;
        }

        # add missing employees to the roster
        my $emps = _employees();
        foreach my $uid (keys %$emps) {
            $uid = lc $uid;
            next if $uid eq $myself;

            my $emp = $emps->{$uid};
            my $ri = $has{$uid} || DJabberd::RosterItem->new(jid  => "$uid\@sixapart.com",
                                                             name => ($emp->{displayName} || $emp->{cn}),
                                                             groups => ["SixApart"]);


            $ri->subscription->set_from;
            $ri->subscription->set_to;
            $roster->add($ri);
        }

        my $post_ct = $roster->items;
        warn "  $post_ct roster items post population...\n";

        $cb->set_roster($roster);
    };

    my $cb2 = DJabberd::Callback->new(set_roster => $on_load_roster,
                                      decline    => sub { $cb->decline });
    $self->SUPER::get_roster($cb2, $jid);
}

sub _employees {
    my $opts = "cn mailLocalAddress mail displayName";
    my @lines = `ldapsearch -H ldap://ldap.sixapart.com -x -b ou=People,dc=SixApart,dc=com $opts`;
    my $line_ct = @lines;
    warn "Got employee lines from LDAP: $line_ct\n";

    my %info;  # uid -> key -> value

#print "@lines\n";
    my $curuid = undef;
    foreach my $line (@lines) {
        $line =~ s/^\#.*//;
        if ($line =~ /^\s*$/) {
            $curuid = undef;
            next;
        }
        if ($line =~ /uid=(\w+)/) {
            $curuid = $1;
        }
        next unless $curuid;

        if ($line =~ /^(\w+): (.+)/) {
            $info{$curuid}{$1} = $2;
        }
    }

    delete $info{'tempaccount'};
    delete $info{'usability'};

    foreach my $uid (keys %info) {
        delete $info{$uid} unless $info{$uid}{mailLocalAddress} || $info{$uid}{mail};
    }
    return \%info;
}

sub load_roster_item {
    my ($self, $jid, $contact_jid, $cb) = @_;

    my $is_employee = sub {
        my $jid = shift;
        return $jid->domain eq "sixapart.com";
    };

    if ($is_employee->($jid) && $is_employee->($contact_jid)) {
        my $both = DJabberd::Subscription->new;
        $both->set_from;
        $both->set_to;
        my $rit = DJabberd::RosterItem->new(jid  => $contact_jid,
                                            subscription => $both);
        $cb->set($rit);
        return;
    }

    $self->SUPER::load_roster_item($jid, $contact_jid, $cb);
}

